initialize() {
	initializeSLiMModelType("nonWF"); // makinf a non wf model
	initializeSLiMOptions(dimensionality="x"); // Modeling phenotype, phenotype is a pseudo-spatial dimension pg 281
	initializeTreeSeq(); // to make trees
	defineConstant("K", 100);	// pathogen carrying capacity
	defineConstant("hK", 1000);	// host carrying capacity
	
	//QT and normalization
	// evenually i want it to be depent on the number of mutations within eachother
	defineConstant("optimum", 5.0);
	defineConstant("sigma_K", 1.0); // tried diff value
	defineConstant("sigma_C", 0.4); // tried diff value
	defineConstant("NORM", dnorm(0.0, mean=0, sd=sigma_C)); //how does it work?
	
	// neutral mutations, which are not allowed to fix?
	initializeMutationType("m1", 0.5, "n", 0.0, 1.0);
	m1.color = "red";
	m1.convertToSubstitution = F;
	
	//host mutations
	initializeMutationType("m2", 0.5, "n", 0.0, 1.0);
	m2.color = "blue";
	m2.convertToSubstitution = F;
	
	//Genomic Element
	initializeGenomicElementType("g1", c(m1, m2), c(10, 1)); // mutation proportions
	// right now # of mutations are even
	//initializeGenomicElementType("g1", c(m1, m2), c(10/11, 1/11)); 
	initializeGenomicElement(g1, 0, 99999);
	initializeMutationRate(1e-7);
	initializeRecombinationRate(1e-8);

}

// to make the mutions truly neutral?
fitness(m1) { return 1.0; }
fitness(m2) { return 1.0; }

reproduction(p1) {
	// pathogen reproduction need 2 to have exponential growth
	p1.addRecombinant(genome1, NULL, NULL, NULL, NULL, NULL);
	p1.addRecombinant(genome1, NULL, NULL, NULL, NULL, NULL);
}

reproduction(p2) {
	//host reproduction 
	p2.addCrossed(individual, p2.sampleIndividuals(1));
}

1 early() {
	sim.addSubpop("p1", 1000); //pathogen initial population 
	sim.addSubpop("p2", 1000); //host initial population 
	p1.setSpatialBounds(c(-100.0, 100.0)); // looking at the phenotype in color
	p2.setSpatialBounds(c(-100.0, 100.0)); // looking at the phenotype 
	//Colors correspond to fitness 
}


early() {
	
	// removing mutations that apear in the wrong population
	muts1 = sim.mutationsOfType(m1);  // pathogen mutations
	muts2 = sim.mutationsOfType(m2); // host mutations
	p1.individuals.genomes.removeMutations(muts2);
	p2.individuals.genomes.removeMutations(muts1);
	
	//	
	//	inds = p1.individuals;
	//	//inds[inds.age > 0].fitnessScaling = 0.0;
	//	p1.fitnessScaling = K / sum(inds.age == 0);
}

1: early() {
	// trying to relate number of m1 to number of m2
	inds_p = p1.individuals;
	inds_h = p2.individuals;
	// which parasite infects each host
	infects = sample(seqLen(p1.individualCount), p2.individualCount, replace=T);
	
	// construct phenotypes and fitness effects from QTLs 
	phenotypes_h = inds_h.sumOfMutationsOfType(m2);
	phenotypes_p = inds_p.sumOfMutationsOfType(m1);
	inds_h.x = phenotypes_h;
	inds_p.x = phenotypes_p;
	
	// outcome of infection	
	outcome = sqrt(2 * 3.1415 * sigma_K) * dnorm(phenotypes_h, phenotypes_p[infects], sigma_K);

	outcome_p = rep(0.0, p1.individualCount);
	for (j in seqLen(p1.individualCount)) {
		outcome_p[j] = sum(1 - outcome[infects == j]);
	}

	inds_h.fitnessScaling = 1 + outcome;
	inds_p.fitnessScaling = 1 + outcome_p;
	
	// we want the sum of the fitness scalings to be hK:
	p2.fitnessScaling = hK / sum(inds_h.fitnessScaling);
	p1.fitnessScaling = K / sum(inds_p.fitnessScaling);
}

late() {
	// fixed at 0.5 in the pathogen, is this correct?
	// print the pop 1 mut freq 
	//	muts = sim.mutationsOfType(m1);
	//	freqs = sim.mutationFrequencies(p1, muts);
	//	if (any(freqs == 0.5))
	//		p1.genomes.removeMutations(muts[freqs == 0.5], F);
	if (sim.generation % 100 == 1)
	{
		phenotypes_p = p1.individuals.x;
		phenotypes_h = p2.individuals.x;
		cat(format("%5d ", sim.generation));
		cat(format("%6.2f ", mean(phenotypes_p)));
		cat(format("%6.2f\n", mean(phenotypes_h)));
	}

}

10000 late() {
	sim.outputFixedMutations();
	//sim.outputFull("~/Desktop/Rotation_2020/model_output.txt"); 
	sim.treeSeqOutput("~/Desktop/Rotation_2020/tree_test.trees"); 
}
